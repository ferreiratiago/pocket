# State Machine Module <!-- omit in toc -->

> ⚠️ Work in progress ⚠️ - At the time of writing this document, the architecture is still being defined.
>
> This is pretty much a POC at the moment.

This document outlines the purpose of this module, its components and how they all interact with the other modules.

## Contents <!-- omit in toc -->
- [Overview](#overview)
- [Code Structure](#code-structure)
- [High Level Architecture](#high-level-architecture)
  - [FSM primer](#fsm-primer)
- [Current State Machine Definition](#current-state-machine-definition)

## Overview

The `StateMachine` module implements a FSM (Finite State Machine) that is responsible for managing the node lifecycle since its internal behaviour can be different depending on certain conditions that are used to determine the current state.

In a nutshell: The FSM guarantees that the node is always in one specific state and verifies state transition (i.e. edges) to/from valid states (i.e. vertices).

## Code Structure

```bash
├── docs
│   ├── CHANGELOG.md              # Changelog
│   ├── README.md                 # You are here
│   └── state-machine.diagram.md  # State machine diagram (generated by visualizer/main.go)
├── fsm.go                        # Finite State Machine definition (events, states, transitions)
├── module.go                     # Implementation of the StateMachine module
└── visualizer
    └── main.go                   # State machine diagram generator
```

## High Level Architecture

The key things to keep in mind are:

- We are using the library "github.com/looplab/fsm" to implement the FSM, essentially here we are wrapping it and integrating it with the rest of the modules. This document won't cover the implementation details of the FSM library which is fairly well documented.
- The **StateMachineModule** can be accessed via the `bus` from any other `IntegratableModule`
- State machine transitions will emit `StateMachineTransitionEvent` events that the modules that are interested can listen to.
- The `node` has a main eventhandler for events that can be used to fan-out the handling to the aforementioned modules that listen to transition events

### FSM primer

The FSM has a declarative definition of an initial state and a set of transitions that have an `Event`, `Source` states and a single `Destination` state.

These are the main building blocks:

- **Event**: An event is a string that represents an action that can trigger a transition. For example, the event `start` can be used to trigger a transition from the `stopped` state to the `starting` state.
- **State**: A state is a string that represents a state that the FSM can be in. For example, the state `stopped` can be used to represent a state where the node is not running.
- **Callback**: A callback is a function that is called when a transition occurs. For example, a callback can be used to log the transition or to perform some other action. (there are various types of callbacks that essentially drive the WHEN they are called and help building more complex behaviours like transition cancelling, etc. but we won't cover them here, please read the FSM library documentation for more details)

## Current State Machine Definition

A diagram of the current state machine definition can be found [here](state-machine.diagram.md)
If you make any changes to it, you can re-generate it via:

```bash
make generate_node_state_machine_diagram
```

<!-- GITHUB_WIKI: state_machine/README -->
